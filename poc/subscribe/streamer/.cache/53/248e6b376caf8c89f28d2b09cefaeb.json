{"id":"screenrecord.js","dependencies":[{"name":"/home/eric/Documents/code/blockchain/streamr/streamr-experientialnft/frontend/package.json","includedInParent":true,"mtime":1726467485028}],"generated":{"js":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nvar RECORDING_ONGOING = false;\nvar recordingToggle = document.getElementById(\"recording-toggle\"); // The button\n\nrecordingToggle.addEventListener(\"click\", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n  return regeneratorRuntime.wrap(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          RECORDING_ONGOING = !RECORDING_ONGOING; // Start / Stop recording\n\n          if (RECORDING_ONGOING) {\n            recordingToggle.innerHTML = \"Stop Recording\";\n            startRecording(); // Start the recording\n          } else {\n            recordingToggle.innerHTML = \"Start Recording\";\n            stopRecording(); // Stop screen recording\n          }\n\n        case 2:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _callee);\n})));\nvar blob,\n    mediaRecorder = null;\nvar chunks = [];\n\nfunction startRecording() {\n  return _startRecording.apply(this, arguments);\n}\n\nfunction _startRecording() {\n  _startRecording = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n    var stream;\n    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return navigator.mediaDevices.getDisplayMedia({\n              video: {\n                mediaSource: \"screen\"\n              },\n              audio: true\n            });\n\n          case 2:\n            stream = _context2.sent;\n            mediaRecorder = new MediaRecorder(stream, {\n              mimeType: \"video/webm\"\n            });\n\n            mediaRecorder.ondataavailable = function (e) {\n              if (e.data.size > 0) {\n                chunks.push(e.data);\n              }\n            };\n\n            mediaRecorder.onstop = function () {\n              var filename = \"nft\"; // Ask the file name\n\n              blob = new Blob(chunks, {\n                type: \"video/webm\"\n              });\n              chunks = []; // Resetting the data chunks\n\n              var dataDownloadUrl = URL.createObjectURL(blob); // Download it onto the user's device\n\n              var a = document.createElement('a');\n              a.href = dataDownloadUrl;\n              a.download = \"\".concat(filename, \".webm\");\n              a.click();\n              URL.revokeObjectURL(dataDownloadUrl);\n            };\n\n            mediaRecorder.start(250);\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _startRecording.apply(this, arguments);\n}\n\nfunction stopRecording() {\n  mediaRecorder.stop(); // Stopping the recording\n}"},"sourceMaps":null,"error":null,"hash":"aca19adaed65355623ddcc7b33eec18f","cacheData":{"env":{}}}